1.如果问题有很多重叠子问题，也就是当前不同决策可能影响到结果不确定时，使用动态规划
2.动态规划类题目，有五个常见的步骤：
（1）确定dp数组及下标含义（大小，类型）
（2）确定递推公式（不同类型题目公式模板不同）
（3）dp数组如何初始化（数组的初始化一般从索引为0处开始，具体数值取决于题）
（4）确定遍历顺序（普通动态规划从左往右即可，但背包问题涉及到背包容量和物品重量先后的选择）
（5）举例推到dp数组（最好能够模拟一下，但实现往往困难）
3.动态规划中常见的递推公式类型（涉及到最的用max/min来处理）：
（1）普通的递推式，与前几个元素有关：array[i] = array[i-1]+array[i-2]（斐波那契数列）
（2）普通递推式，但当前状态与前面的最值有关系：array[i] = min(array[i-2], array[i-1])。见746
（3）01背包问题，每个元素使用一次，寻找符合条件的最大值/背包装满的最大价值：dp[j] = max(dp[j], dp[j-weight[i]]+value[i]);
（4）01背包问题，每个元素使用一次，判断是否等于某个固定值/能否将背包装满。dp[j] = max(dp[j], dp[j-nums[i]]+nums[i]);给一个维度，价值和物品重量都是它。见416
（5）01背包问题，求装满背包有几种方法。dp[j] += dp[j-nums[i]];见494
（6）01背包问题，求最大个数问题。dp[i][j] = max(dp[i][j], dp[i-zeronum][j-onenum]+1);从本身值和+1中选择。见474
（7）完全背包问题，求最小个数：dp[j] = min(dp[j], dp[j-coins[i]]+1);见322
4.对于二维dp数组的初始化既要有i=0,也要有j=0。不是全部为0即可，还要根据题中要求。见62/63
5.拆数问题时，在决定每一个数时，除了利用两重for循环之外，在里层决定的时候还要看拆成两个或者是多个。即：dp[i] = max(dp[i], max(j*(i-j), j*dp[i-j])); // 最大值选择，包括很多组，对应外面的max。每一组中，拆成两个还是多个再选一下。见343
6.背包问题中常见有两种：
（1）01背包：每个物品只可以选一次
（2）完全背包：每个物品选择不限次数
7.对于01背包问题，可以使用二维数组存储，也可以使用一维数组存储.都是双重for循环，先遍历物品再遍历背包：
（1）	
	for (int i=1; i<dp.size(); i++) {
		for (int j=1; j<dp[0].size(); j++) {
			if (j < weight[i]) // 背包容量比体积小 
				dp[i][j] = dp[i-1][j];
			else
				dp[i][j] = max(dp[i-1][j], dp[i-1][j-weight[i]]+value[i]); // 容量比体积大，在加和不加中选择 
		}
	}
（2）注意里层for循环从大到小，要使用上一层的数据
	for (int i=0; i<=weight.size(); i++) { // 遍历物品 
		for (int j=bagWeight; j>=weight[i]; j--) { // 遍历体积，必须从后往前。只需更新比物品体积大(>=)的位置即可 
			dp[j] = max(dp[j], dp[j-weight[i]]+value[i]);
		}
	}
8.从一堆数里选择，能否总和达到定值。可归类为背包问题
9.完全背包的两层for循环中，顺序可以颠倒，但一般是先物品，再背包体积。
10.完全背包问题，背包体积的循环是从左向右。从num[i]开始，到背包体积最大结束
11.完全背包问题，组合和排列遍历顺序不同：组合时物品在外层，背包容量在内层。排列时物品在内层，背包容量在外层
12.对于环形问题，间隔才能取值。可以分两段：有首无尾，有尾无首。在两种中做选择。见213
13.树型问题和动态规划可以结合，注意树的递归。确定遍历顺序，一般是后序遍历。见337
14.总结：对于动态规划问题，首先根据题意判断。是否有重叠，有的话说明是动态规划问题。再区分是普通动态规划还是背包问题。背包问题看取值次数确定01背包还是完全背包。根据不同的情况状态转移方程求解。完全背包还要考虑是排列还是组合。
