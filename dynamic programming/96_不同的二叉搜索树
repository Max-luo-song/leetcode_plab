/*
 *  算法思想：本题代码简单，但思路不好想。首先根据二叉树子树的特点，判断出是一道动态规划问题。利用之前的结果求当前
 *            从示例可以看出，头节点分三种类型：1为根，2为根，3为根。左右子树的结构分别又是之前n值较小的结构。
 *            分别统计1~n为根节点的可能，累加左节点乘右节点。动态规划，以数目确定
*/
class Solution {
public:
    int numTrees(int n) {
        vector<int> dp(n+1);
        dp[0] = 1;
        for (int i=1; i<=n; i++) {
            for (int j=1; j<=i; j++) {
                dp[i] += dp[j-1] * dp[i-j]; // 第j位时，左边有j-1个，共i个，右边有i-j个
            }
        }
        return dp[n];
    }
};
